# -*- coding: utf-8 -*-
"""modÃ¨le_gpt4mini_guide_segmentÃ©_5runs.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12VuzpLgUevNWsVDqM9yWRQlJhm4gu0fs
"""

from openai import OpenAI
import pandas as pd
from tqdm import tqdm

client = OpenAI(api_key="")

import collections
# =========================
# 2. PROMPTS POUR CHAQUE TEST
# =========================

CRAN_PROMPT = """
Tu es linguiste annotateur. RÃ©ponds UNIQUEMENT par "OUI" ou "NON".

TEST CRAN â€” mot exclusivement figÃ©
Question : lâ€™expression contient-elle un mot exclusivement figÃ© ?

Un mot exclusivement figÃ© :
- nâ€™existe pas comme mot autonome,
- nâ€™apparaÃ®t jamais en dehors de lâ€™expression,
- nâ€™a plus dâ€™usage productif moderne.

Exemple OUI : Â« us Â» dans Â« us et coutumes Â»
Exemple NON : Â« bleu Â» dans Â« cordon bleu Â»

RÃ©ponds uniquement OUI ou NON.
Puis ajoute UNE phrase trÃ¨s courte expliquant la raison.
Format obligatoire :
OUI/NON
Explication : <phrase trÃ¨s courte>

Expression : {expression}
Contexte : {contexte}
"""

MORPH_PROMPT = """
Tu es linguiste annotateur. RÃ©ponds UNIQUEMENT par "OUI" ou "NON".

TEST MORPH â€” modification morphologique
Question : la flexion (pluriel, genre) rend-elle lâ€™expression agrammaticale ou Ã©trange ?

Exemple OUI : Â« garde du corps Â» â†’ Â« gardes du corps Â»
Exemple NON : Â« livre scolaire Â» â†’ Â« livres scolaires Â»

RÃ©ponds uniquement OUI ou NON.
Puis ajoute UNE phrase trÃ¨s courte expliquant la raison.
Format obligatoire :
OUI/NON
Explication : <phrase trÃ¨s courte>

Expression : {expression}
Contexte : {contexte}
"""

SYNT_PROMPT = """
Tu es linguiste annotateur. RÃ©ponds UNIQUEMENT par "OUI" ou "NON".

TEST SYNT â€” modification syntaxique
Question : un changement dâ€™ordre ou de structure modifie-t-il fortement le sens ou le rend-il agrammaticale ou bizzare ?

Exemple OUI : Â« pomme de terre Â» â‰  Â« pomme terrestre Â»
Exemple NON : Â« comitÃ© rÃ©gional Â» â‰ˆ Â« comitÃ© de la rÃ©gion Â»

RÃ©ponds uniquement OUI ou NON.
Puis ajoute UNE phrase trÃ¨s courte expliquant la raison.
Format obligatoire :
OUI/NON
Explication : <phrase trÃ¨s courte>

Expression : {expression}
Contexte : {contexte}
"""

LEX_PROMPT = """
Tu es linguiste annotateur. RÃ©ponds UNIQUEMENT par "OUI" ou "NON".

TEST LEX â€” substitution lexicale
Question : remplacer un Ã©lÃ©ment par un synonyme rend-il lâ€™expression anormale, agrammaticale ou bizzare ?

Exemple OUI : Â« eau de vie Â» â†’ Â« boisson de vie Â»
Exemple NON : Â« prix rÃ©duit Â» â†’ Â« tarif rÃ©duit Â»

RÃ©ponds uniquement OUI ou NON.
Puis ajoute UNE phrase trÃ¨s courte expliquant la raison.
Format obligatoire :
OUI/NON
Explication : <phrase trÃ¨s courte>

Expression : {expression}
Contexte : {contexte}
"""

MODIF_PROMPT = """
Tu es linguiste annotateur. RÃ©ponds UNIQUEMENT par "OUI" ou "NON".

TEST MODIF â€” insertion dâ€™un modifieur
Question : lâ€™insertion dâ€™un modifieur (adjectif/adverbe) interne rend-elle lâ€™expression anormale, agrammaticale ou bizzare ?

Exemple OUI : Â« pomme verte de terre Â»
Exemple NON : Â« roman contemporain policier Â»

RÃ©ponds uniquement OUI ou NON.
Puis ajoute UNE phrase trÃ¨s courte expliquant la raison.
Format obligatoire :
OUI/NON
Explication : <phrase trÃ¨s courte>

Expression : {expression}
Contexte : {contexte}
"""

SEMREST_PROMPT = """
Tu es linguiste annotateur. RÃ©ponds UNIQUEMENT par "OUI" ou "NON".

TEST SEM-REST â€” restrictions sÃ©mantiques
Question : la tÃªte nominale (le nom principal de l'expression) telle qu'elle est utilisÃ©e dans cette expression (dans son sens contextuel) a-t-elle un ensemble restreint de collocatifs naturels ?

Exemple OUI : Â« professeur de linguistique Â» â†’ mais aussi Â« professeur de maths Â», Â« professeur de chimie Â», Â« professeur de littÃ©rature Â» (ensemble restreint aux domaines acadÃ©miques)
Exemple NON : Â« Ã©vÃ©nement majeur Â» â†’ mais aussi Â« Ã©vÃ©nement local Â», Â« Ã©vÃ©nement imprÃ©vu Â», Â« Ã©vÃ©nement politique Â», etc. (ensemble trÃ¨s ouvert)

âš ï¸ Attention : Tu dois analyser UNIQUEMENT la tÃªte nominale, pas lâ€™expression entiÃ¨re.
On vÃ©rifie avec quels collocatifs naturels se combine la tÃªte nominale seule.

Exemples :
- dans Â« roman policier Â» â†’ la tÃªte nominale = Â« roman Â», pas Â« roman policier Â»
- dans Â« pomme de terre Â» â†’ la tÃªte nominale = Â« pomme Â», pas Â« pomme de terre Â»

Ne prends jamais lâ€™expression complÃ¨te comme base de comparaison.
Toujours la tÃªte nominale seule.


RÃ©ponds uniquement OUI ou NON.
Puis ajoute UNE phrase trÃ¨s courte expliquant la raison.
Format obligatoire :
OUI/NON
Explication : <phrase trÃ¨s courte>

Expression : {expression}
Contexte : {contexte}
"""

ID_PROMPT = """
Tu es linguiste annotateur. RÃ©ponds UNIQUEMENT par "OUI" ou "NON".

TEST ID â€” type naturel
Question : lâ€™expression dÃ©signe-t-elle une sous-catÃ©gorie naturelle et littÃ©rale du noyau nominal ?


âš ï¸ Attention : tu dois identifier la tÃªte syntaxique de lâ€™expression :
le nom qui constitue le noyau de la construction nominale. Lâ€™objectif du test est de dÃ©terminer si lâ€™expression dÃ©signe une sous-catÃ©gorie
naturelle de ce noyau.

Pour rÃ©pondre OUI, le noyau nominal doit garder son sens et lâ€™expression doit dÃ©signer un type de ce nom. La rÃ©ponse est plus souvent OUI que NON, donc dans les cas d'incertitude penche vers OUI.

Exemples ID = NON :
- Â« Ã®le flottante Â» (dessert) : ce nâ€™est pas un type d'Ã®le, c'est un dessert
- Â« forÃªt noire Â» (gÃ¢teau) : ce nâ€™est pas un type de forÃªt, c'est un gÃ¢teau

Exemple ID = OUI :
- Â« Ã©vÃ©nement culturel Â» : câ€™est un type dâ€™Ã©vÃ©nement
- Â« chaise en bois Â» : câ€™est un type de chaise
- Â« vÃ©hicule Ã©lectrique Â» : câ€™est un type de vÃ©hicule
- Â« bouteille en plastique Â» : câ€™est un type de bouteille
- Â« porte coulissante Â» : câ€™est un type de porte



RÃ©ponds uniquement OUI ou NON.
Puis ajoute UNE phrase trÃ¨s courte expliquant la raison.
Format obligatoire :
OUI/NON
Explication : <phrase trÃ¨s courte>

Expression : {expression}
Contexte : {contexte}
"""

OPAC_PROMPT = """
Tu es linguiste annotateur. RÃ©ponds UNIQUEMENT par "OUI" ou "NON".

ğŸ”µ TEST OPAC â€” opacitÃ© sÃ©mantique

Question : le sens global ne correspond-il pas Ã  la somme des sens littÃ©raux des composants ?

Si le noyau nominal nâ€™est pas littÃ©ral â†’ OPAC = OUI.

Exemples OUI :
- Â« Ã®le flottante Â» (pas une Ã®le flotte)
- Â« forÃªt noire Â» (pas une forÃªt qui est noire)
- Â« lune de miel Â» (pas une lune construite de miel)

Exemples NON :
- Â« analyse des donnÃ©es Â» (c'est une analyse impliquant des donnÃ©es)
- Â« dÃ©cision administrative Â» (c'est une dÃ©c ision qui est de type administratif)

Expression : Â« {expression} Â»
Contexte : {contexte}

RÃ©ponds uniquement OUI ou NON.
Puis ajoute UNE phrase trÃ¨s courte expliquant la raison.
Format obligatoire :
OUI/NON
Explication : <phrase trÃ¨s courte>

Expression : {expression}
Contexte : {contexte}
"""


# =========================
# 3. Ğ’Ğ¡ĞŸĞĞœĞĞ“ĞĞ¢Ğ•Ğ›Ğ¬ĞĞĞ¯ Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ¯ Ğ”Ğ›Ğ¯ ĞĞ”ĞĞĞ“Ğ Ğ¢Ğ•Ğ¡Ğ¢Ğ
# =========================

def ask_test(prompt_template, expression, examples):
    contexte = "" if examples is None or pd.isna(examples) else str(examples)
    prompt = prompt_template.format(expression=expression, contexte=contexte)

    resp = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}],
        max_tokens=50,
    )

    full = (resp.choices[0].message.content or "").strip()

    # Ğ¿ĞµÑ€Ğ²Ğ°Ñ ÑÑ‚Ñ€Ğ¾ĞºĞ° = Ğ¾Ñ‚Ğ²ĞµÑ‚ OUI/NON
    first_line = full.split("\n")[0].strip().upper()

    decision = "OUI" if first_line == "OUI" else "NON"

    # Ğ¾Ğ±ÑŠÑÑĞ½ĞµĞ½Ğ¸Ğµ = Ğ²ÑÑ‘, Ñ‡Ñ‚Ğ¾ Ğ¸Ğ´Ñ‘Ñ‚ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ¾ĞºĞ¸
    explanation = ""
    if "\n" in full:
        explanation = full.split("\n", 1)[1].strip()

    return decision, explanation


# =========================
# 4. Ğ”Ğ•Ğ Ğ•Ğ’Ğ Ğ Ğ•Ğ¨Ğ•ĞĞ˜Ğ™ Ğ”Ğ›Ğ¯ Ğ’Ğ¡Ğ•Ğ¥ Ğ¢Ğ•Ğ¡Ğ¢ĞĞ’
# =========================

def annotate_expression(expression, examples, debug=False):
    tests = {}

    # CRAN
    d, e = ask_test(CRAN_PROMPT, expression, examples)
    tests["CRAN"] = (d, e)
    if d == "OUI":
        return tests, "expression_idiomatique"

    # MORPH
    d, e = ask_test(MORPH_PROMPT, expression, examples)
    tests["MORPH"] = (d, e)
    if d == "OUI":
        d2, e2 = ask_test(ID_PROMPT, expression, examples)
        tests["ID"] = (d2, e2)
        if d2 == "NON":
            return tests, "expression_idiomatique"
        d3, e3 = ask_test(OPAC_PROMPT, expression, examples)
        tests["OPAC"] = (d3, e3)
        return tests, ("collocation_opaque" if d3 == "OUI" else "collocation_transparente")

    # SYNT
    d, e = ask_test(SYNT_PROMPT, expression, examples)
    tests["SYNT"] = (d, e)
    if d == "OUI":
        d2, e2 = ask_test(ID_PROMPT, expression, examples)
        tests["ID"] = (d2, e2)
        if d2 == "NON":
            return tests, "expression_idiomatique"
        d3, e3 = ask_test(OPAC_PROMPT, expression, examples)
        tests["OPAC"] = (d3, e3)
        return tests, ("collocation_opaque" if d3 == "OUI" else "collocation_transparente")

    # LEX
    d, e = ask_test(LEX_PROMPT, expression, examples)
    tests["LEX"] = (d, e)
    if d == "OUI":
        d2, e2 = ask_test(ID_PROMPT, expression, examples)
        tests["ID"] = (d2, e2)
        if d2 == "NON":
            return tests, "expression_idiomatique"
        d3, e3 = ask_test(OPAC_PROMPT, expression, examples)
        tests["OPAC"] = (d3, e3)
        return tests, ("collocation_opaque" if d3 == "OUI" else "collocation_transparente")

    # MODIF
    d, e = ask_test(MODIF_PROMPT, expression, examples)
    tests["MODIF"] = (d, e)
    if d == "OUI":
        d2, e2 = ask_test(ID_PROMPT, expression, examples)
        tests["ID"] = (d2, e2)
        if d2 == "NON":
            return tests, "expression_idiomatique"
        d3, e3 = ask_test(OPAC_PROMPT, expression, examples)
        tests["OPAC"] = (d3, e3)
        return tests, ("collocation_opaque" if d3 == "OUI" else "collocation_transparente")

    # SEM-REST
    d, e = ask_test(SEMREST_PROMPT, expression, examples)
    tests["SEM-REST"] = (d, e)
    if d == "NON":
        return tests, "expression_libre"

    # ID
    d, e = ask_test(ID_PROMPT, expression, examples)
    tests["ID"] = (d, e)
    if d == "NON":
        return tests, "expression_idiomatique"

    # OPAC
    d, e = ask_test(OPAC_PROMPT, expression, examples)
    tests["OPAC"] = (d, e)
    return tests, ("collocation_opaque" if d == "OUI" else "collocation_transparente")



def annotate_with_majority_vote(expression, examples, n=5, debug=False):
    runs = []  # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ¼ (category, tests)

    for i in range(n):
        if debug:
            print(f"\n--- RUN {i+1}/{n} ---")
        tests, category = annotate_expression(expression, examples, debug=False)
        runs.append({"category": category, "tests": tests})

    # ĞŸĞ¾Ğ´ÑÑ‡Ñ‘Ñ‚ Ğ³Ğ¾Ğ»Ğ¾ÑĞ¾Ğ²
    all_categories = [r["category"] for r in runs]
    counter = collections.Counter(all_categories)

    # --- ĞĞ¾Ğ²Ğ¾Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ¾ ---
    # 1. Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, ĞµÑÑ‚ÑŒ Ğ»Ğ¸ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸ Ñ â‰¥ 2 Ğ³Ğ¾Ğ»Ğ¾ÑĞ°Ğ¼Ğ¸ (ĞºÑ€Ğ¾Ğ¼Ğµ expression_libre)
    major_candidates = [
        cat for cat, count in counter.items()
        if count >= 2 and cat != "expression_libre"
    ]

    if major_candidates:
        # Ğ•ÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ Ñ…Ğ¾Ñ‚Ñ Ğ±Ñ‹ Ğ¾Ğ´Ğ½Ğ° ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ñ â‰¥ 2 Ğ¸ â‰  libre â†’ Ğ²Ñ‹Ğ¸Ğ³Ñ€Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ¾Ğ½Ğ°/Ğ¾Ğ½Ğ¸
        if len(major_candidates) == 1:
            chosen = major_candidates[0]
            # Ñ‚ĞµÑÑ‚Ñ‹ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ³Ğ¾ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ° Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ¹ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸
            chosen_tests = None
            for r in reversed(runs):
                if r["category"] == chosen:
                    chosen_tests = r["tests"]
                    break

            return {
                "votes": all_categories,
                "final_category": chosen,
                "tie": None,
                "tests": chosen_tests,
            }

        else:
            # ĞĞ¸Ñ‡ÑŒÑ Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¸Ğ¼Ğ¸ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸ÑĞ¼Ğ¸, Ğ½Ğ°Ğ±Ñ€Ğ°Ğ²ÑˆĞ¸Ğ¼Ğ¸ â‰¥2 Ğ³Ğ¾Ğ»Ğ¾ÑĞ°
            return {
                "votes": all_categories,
                "final_category": "/".join(major_candidates),
                "tie": major_candidates,
                "tests": None,
            }

    # 2. Ğ•ÑĞ»Ğ¸ Ğ½ĞµÑ‚ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¹ â‰¥2 ĞºÑ€Ğ¾Ğ¼Ğµ expression_libre â†’ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ expression_libre
    if counter.get("expression_libre", 0) >= 2:
        chosen = "expression_libre"
        chosen_tests = None
        # Ğ½Ğ°Ğ¹Ğ´Ñ‘Ğ¼ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ Ğ·Ğ°Ğ¿ÑƒÑĞº, Ğ³Ğ´Ğµ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ»Ğ¸ expression_libre
        for r in reversed(runs):
            if r["category"] == chosen:
                chosen_tests = r["tests"]
                break

        return {
            "votes": all_categories,
            "final_category": chosen,
            "tie": None,
            "tests": chosen_tests,
        }

    # 3. Ğ•ÑĞ»Ğ¸ Ğ½Ğ¸ Ğ¾Ğ´Ğ½Ğ° ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ±Ñ€Ğ°Ğ»Ğ° â‰¥2 Ğ³Ğ¾Ğ»Ğ¾ÑĞ¾Ğ² â†’ Ñ‡Ğ¸ÑÑ‚Ğ°Ñ Ğ½Ğ¸Ñ‡ÑŒÑ Ğ¼ĞµĞ¶Ğ´Ñƒ 1Ã—1Ã—1â€¦
    tied = list(counter.keys())

    return {
        "votes": all_categories,
        "final_category": "/".join(tied),
        "tie": tied,
        "tests": None
    }


# =========================
# 5. ĞĞ‘Ğ’ĞĞ Ğ¢ĞšĞ Ğ”Ğ›Ğ¯ Ğ—ĞĞŸĞ˜Ğ¡Ğ˜ Ğ’ DATAFRAME
# =========================

def generate_annotation_with_llm(expression, examples, debug=False):
    result = annotate_with_majority_vote(
        expression, examples, n=5, debug=debug
    )

    votes = result["votes"]
    final_category = result["final_category"]
    tie = result.get("tie")
    tests = result.get("tests")

    lines = []

    # ---- Ğ’Ğ¡Ğ• Ğ“ĞĞ›ĞĞ¡Ğ ----
    lines.append("Votes :")
    for v in votes:
        lines.append(f"- {v}")

    # ---- Ğ•Ğ¡Ğ›Ğ˜ Ğ‘Ğ«Ğ›Ğ ĞĞ˜Ğ§Ğ¬Ğ¯ ----
    if tie:
        lines.append(f"\nÃ‰GALITÃ‰ : {', '.join(tie)}")

    # ---- Ğ¤Ğ˜ĞĞĞ›Ğ¬ĞĞĞ¯ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯ ----
    lines.append(f"\nCATÃ‰GORIE FINALE : {final_category}")

    # ---- ĞĞ‘ĞªĞ¯Ğ¡ĞĞ•ĞĞ˜Ğ¯ Ğ¢Ğ•Ğ¡Ğ¢ĞĞ’ (ĞµÑĞ»Ğ¸ Ñƒ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğ¹ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸ ĞµÑÑ‚ÑŒ tests) ----
    if tests:
        lines.append("\nExplications des tests menant Ã  la catÃ©gorie finale :")
        order = ["CRAN", "MORPH", "SYNT", "LEX", "MODIF", "SEM-REST", "ID", "OPAC"]
        for t in order:
            if t in tests:
                decision, expl = tests[t]
                lines.append(f"{t} : {decision}")
                if expl:
                    lines.append(f"  Explication : {expl}")

    text = "\n".join(lines)

    if debug:
        print("\n=== RÃ‰SUMÃ‰ (majority vote + explications) ===\n")
        print(text)

    return text




# =========================
# 6. ĞĞ‘Ğ ĞĞ‘ĞĞ¢ĞšĞ EXCEL
# =========================

chunk_file_path = "nominal_part_4.xlsx"
df_chunk = pd.read_excel(chunk_file_path)

df_chunk["llm_raw_response"] = None

for index, row in tqdm(
    df_chunk.iterrows(),
    total=len(df_chunk),
    desc="Annotation des expressions nominales",
    unit="expr",
):
    expression = row.get("expression")
    examples = row.get("examples_joined")

    if pd.isna(expression) or str(expression).strip() == "":
        df_chunk.at[index, "llm_raw_response"] = "N/A (missing expression)"
        continue

    debug_flag = index < 1  # Ğ´ĞµĞ±Ğ°Ğ³ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ¾ĞºĞ¸

    llm_answer = generate_annotation_with_llm(
        expression=expression,
        examples=examples,
        debug=debug_flag,
    )

    df_chunk.at[index, "llm_raw_response"] = llm_answer

output_filename = "annotated_nominal_part_4_gpt4omini_segmented_tests.xlsx"
df_chunk.to_excel(output_filename, index=False)
print(f"Annotated and saved {output_filename}")